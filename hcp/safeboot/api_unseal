#!/bin/bash

PROG=${0##*/}
BINDIR=$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")
TOP=$(dirname "$BINDIR")

if [[ -s $TOP/safeboot/functions.sh ]]; then
	# shellcheck disable=SC1090 source=functions.sh
	. "$TOP/safeboot/functions.sh"
else
	echo "Unable to find Safeboot function library" 1>&2
	exit 1
fi
if [[ -d $TOP/safeboot ]]; then
	export PATH=$TOP/safeboot:$PATH
fi

set -euo pipefail
shopt -s extglob

# shellcheck disable=SC2209
function usage {
	((${1:-1} > 0)) && exec 1>&2
	pager=cat
	if [[ -t 0 && -t 1 && -t 2 ]]; then
		if [[ -z ${PAGER:-} ]] && type less >/dev/null 2>&1; then
			pager=less
		elif [[ -z ${PAGER:-} ]] && type more >/dev/null 2>&1; then
			pager=more
		elif [[ -n ${PAGER:-} ]]; then
			pager=$PAGER
		fi
	fi
        $pager <<EOF
       $PROG [-s] VERIFYKEY INPUT OUTPUT

  {$PROG}, by default, decrypts and signature-verifies an input file
  bundle using the given parameters. ({INPUT} is the directory holding
  the input files.) If the '-s' option is provided, only
  signature-verification is performed, in which case the unencrypted
  {INPUT}/data is expected to already exist.

  Options:

	-s		Signature-verify-only

  Arguments:

        {EKPUB}         Path to the recipient's TPM Endorsement Key
	{SIGNKEY}	Path to an RSA signing key
	{POLICY}        Policy hex string
	{INPUT}         The asset directory to be unsealed
	{OUTPUT}        Name of the output asset file
EOF
	exit "${1:-1}"
}

signonly=no

if (($# >= 1)) && [[ $1 == '-s' ]]; then
	signonly=yes
	shift
fi
if (($# != 3)); then
	echo "Error: wrong number of arguments" >&2
	exit 1
fi
verifykey=$1
input=$2
output=$3

tmp=
function cleanup() {
	[[ -d $tmp ]] && rm -rf $tmp
}
trap cleanup EXIT
tmp=$(mktemp -d)

[[ -d $input ]] ||
	(echo "Error: input directory doesn't exist" >&2 && exit 1) ||
	exit 1

if [[ "x$signonly" == "xno" ]]; then
	# TODO: what is the purpose of $input/policy in this unsealing
	# process? Did we have a reason to write it in the first place?
	tpm2-recv "$input/symkeyenc" \
		"$tmp/symkey" \
		tpm2 policypcr '--pcr-list=sha256:11' 2> /dev/null
	aead_decrypt "$input/enc" \
		"$tmp/symkey" \
		"$tmp/output"
	sigsource="$tmp/output"
else
	sigsource="$input/data"
fi
openssl pkeyutl -verify -keyform PEM -pubin -inkey "$verifykey" \
	-in <(sha256 < "$sigsource" | hex2bin) \
	-sigfile "$input/sig"
# The signature check didn't fail, so copy the decrypted asset to
# its destination
cp "$sigsource" "$output"
